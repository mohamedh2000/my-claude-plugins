---
description: File-based planning with parallel sub-agent execution
argument-hint: "[file_path] or task description"
---

# Planning with Files (Parallel Edition)

Fork of planning-with-files with support for **parallel sub-agent execution**.

## Usage

```
/planning-parallel                                    # Use task_plan.md in project root
/planning-parallel .claude/PRD-notifications/task_plan.md   # Use PRD folder from /prd
```

## Argument Handling

$ARGUMENTS

**If argument is a file path** (ends with `.md` or contains `/`):
- Use that file as the task plan
- Look for `findings.md` and `progress.md` in the same directory
- Create `findings.md` and `progress.md` if they don't exist

**If empty or a description**:
- Look for `task_plan.md` in project root (current working directory)
- Look for `findings.md` and `progress.md` in project root
- Create `findings.md` and `progress.md` if they don't exist
- Error if `task_plan.md` doesn't exist (run `/prd` first)

## Core Concept

```
Context Window = RAM (volatile, limited)
Filesystem = Disk (persistent, unlimited)
→ Anything important gets written to disk.
```

## The Three-File Memory Architecture

| File | Purpose | When to Update |
|------|---------|----------------|
| `task_plan.md` | Tasks, groups, progress, decisions | After each task/group |
| `findings.md` | Research, discoveries, decisions | After ANY discovery |
| `progress.md` | Session log, test results | Throughout session |

---

## PARALLEL EXECUTION PROTOCOL

This fork adds memory-safe parallel execution for tasks generated by `/prd`.

### When to Use Parallel Execution

Use parallel execution when task_plan.md contains:
- `## Execution Groups` table with multiple tasks per group
- Tasks marked with `**Group:** N`
- Multiple tasks with no dependencies between them

### Memory Architecture for Parallel Agents

To avoid race conditions, each sub-agent gets **isolated memory files**:

```
SHARED FILES (sub-agents READ only):
├── task_plan.md          ← Orchestrator owns
├── findings.md           ← Context for sub-agents
├── progress.md           ← Context for sub-agents
└── [PLAN_DIR]/PRD.md     ← Full requirements (same folder as task_plan.md)

ISOLATED FILES (each sub-agent WRITES to their own):
├── findings_[TASK-ID].md    ← Agent's discoveries
└── progress_[TASK-ID].md    ← Agent's session log
```

### Parallel Execution Flow

**1. DETECT** - Read task_plan.md, find the current Execution Group

**2. SPAWN IN BACKGROUND** - For each task in the parallel group:
- Use Task tool with appropriate agent type
- **CRITICAL**: Set `run_in_background: true` for ALL parallel agents
- ALL tasks in group spawn in a SINGLE message (true parallel)
- Each agent gets their isolated file names
- Store the returned `output_file` paths and `task_id` for each agent

**3. MONITOR & UPDATE** - While agents execute in background:
- Use `TaskOutput` tool with `block: false` to check status without blocking
- Alternatively, use `Read` tool on the `output_file` paths
- **Provide progress updates to the user** as agents complete:
  - "✓ [TASK-ID] complete - [brief summary]"
  - "⏳ [TASK-ID] still in progress..."
- Continue checking periodically until all agents in the group finish

**4. EXECUTE** - Each sub-agent (running in background):
- READS: task_plan.md, findings.md, progress.md, PRD
- WRITES: findings_[TASK-ID].md, progress_[TASK-ID].md
- DOES NOT MODIFY: shared files

**5. MERGE** - After ALL agents in group complete:
- Read all findings_[TASK-ID].md from the group
- Append to findings.md under `## [TASK-ID] Findings`
- Read all progress_[TASK-ID].md from the group
- Append to progress.md
- Update task_plan.md statuses
- Delete sub-agent files (cleanup)
- **Report to user**: "Group [N] complete. Moving to Group [N+1]..."

**6. CONTINUE** - Proceed to next group

### Sub-Agent Prompt Template

For EACH parallel task, spawn with `run_in_background: true`:

```
run_in_background: true
Agent type: [from task_plan.md - senior-backend-engineer | ui-react-specialist | general-purpose]

You are executing [TASK-ID]: [Task Title] for [feature-name].

CONTEXT (read first, DO NOT modify):
- task_plan.md → Find your task under [TASK-ID]
- findings.md → Decisions and rationale from discovery
- [PLAN_DIR]/PRD.md → Full requirements (same folder as task_plan.md)
- .claude/CODEBASE_ARCHITECTURE.md → Codebase patterns

YOUR ISOLATED MEMORY FILES (create and update throughout):
- findings_[TASK-ID].md → Your discoveries, decisions, technical notes
- progress_[TASK-ID].md → Your session log: actions, files modified, errors

EXECUTE:
Complete all subtasks for [TASK-ID] listed in task_plan.md.

WHEN COMPLETE:
Return summary: files created/modified, status (complete/blocked), any blockers.
```

### Sub-Agent Continuation Protocol (NO COMPACTION - Handoff Only)

**CRITICAL: Sub-agents must NEVER compact their context.** If approaching context limits, they must checkpoint their progress and request a NEW agent to continue. The orchestrator handles spawning the continuation agent.

When a sub-agent approaches context limits:

**1. CHECKPOINT** - Write progress to isolated files:
```markdown
## findings_[TASK-ID].md
### Checkpoint at [timestamp]
**Completed:**
- [x] Subtask 1: Created UserModel.js
- [x] Subtask 2: Added migrations

**In Progress:**
- [ ] Subtask 3: API endpoints (started, 2 of 5 done)

**Key Decisions:**
- Using UUID for user IDs because [reason]
- Skipped soft-delete, using hard-delete because [reason]

**Next Steps:**
1. Complete remaining 3 endpoints in UserController
2. Add input validation
3. Write tests
```

```markdown
## progress_[TASK-ID].md
### Files Modified
- src/models/UserModel.js (created)
- src/migrations/001_users.js (created)
- src/controllers/UserController.js (in progress - 2/5 endpoints)

### Errors Encountered
- None yet

### Continuation Required
Status: PARTIAL_COMPLETE
Reason: Context compaction needed
Resume from: Subtask 3, endpoint 3 of 5
```

**2. RETURN WITH CONTINUATION FLAG** - End with:
```
STATUS: PARTIAL_COMPLETE
CONTINUATION_REQUIRED: true
RESUME_FROM: "Subtask 3 - Create remaining 3 API endpoints"
FILES_TO_READ: findings_[TASK-ID].md, progress_[TASK-ID].md
```

**3. ORCHESTRATOR DETECTS & RESPAWNS** - When orchestrator sees `CONTINUATION_REQUIRED`:
```
Spawn new agent with:
- Same [TASK-ID]
- Add to prompt: "CONTINUATION - Read findings_[TASK-ID].md and progress_[TASK-ID].md first. Previous agent completed subtasks 1-2. Resume from: [RESUME_FROM]"
```

**4. NEW AGENT READS CHECKPOINT** - Continuation agent:
- Reads isolated files to understand completed work
- Skips completed subtasks
- Resumes from checkpoint

### Orchestrator Monitoring Loop

While background agents are running, the orchestrator should:

```
1. SPAWN all group tasks with run_in_background: true
   → Store task_id and output_file for each

2. MONITOR LOOP (repeat until all complete):
   a. For each running agent:
      - Use TaskOutput with block: false, timeout: 5000
      - OR Read the output_file to check progress

   b. Report status updates to user:
      - "⏳ Running: BE-001, FE-001, INFRA-001..."
      - "✓ BE-001 complete: Created user model and migrations"
      - "✓ FE-001 complete: Built UserProfile component"
      - "⏳ Still waiting on: INFRA-001..."

   c. If all complete, exit loop

3. MERGE results from all agents
4. CONTINUE to next group
```

### Post-Group Merge Checklist

After ALL agents in a parallel group complete:

- [ ] Collect all findings_[TASK-ID].md files from the group
- [ ] Append each to findings.md under appropriate headers
- [ ] Collect all progress_[TASK-ID].md files from the group
- [ ] Append each to progress.md
- [ ] Update task_plan.md: Mark all group tasks as complete
- [ ] Log any errors to Errors Encountered table
- [ ] Delete all sub-agent isolated files
- [ ] Check if next group is unblocked, proceed accordingly

---

## Sequential Execution (Non-Parallel Tasks)

For tasks NOT in a parallel group, execute normally:

1. Read task_plan.md to identify current task
2. Execute the task directly (no sub-agent needed)
3. Update findings.md with discoveries
4. Update progress.md with actions taken
5. Mark task complete in task_plan.md
6. Proceed to next task

---

## Critical Rules

### 1. Read Before Decide
Before major decisions, read task_plan.md. Keeps goals in attention window.

### 2. The 2-Action Rule
> "After every 2 view/browser/search operations, IMMEDIATELY save to findings.md"

### 3. Never Repeat Failures
```
if action_failed:
    next_action != same_action
```
Track what you tried. Mutate the approach.

### 4. Log ALL Errors
Every error goes in task_plan.md AND progress.md.

### 5. Single Writer for Shared Files
During parallel execution, ONLY orchestrator writes to:
- task_plan.md
- findings.md (via merge)
- progress.md (via merge)

### 6. No Compaction - Handoff Only
Sub-agents must **NEVER** compact their context. When approaching limits:
1. Checkpoint progress to isolated files
2. Return with `CONTINUATION_REQUIRED: true`
3. Orchestrator spawns fresh agent to continue

---

## The 3-Strike Error Protocol

```
ATTEMPT 1: Diagnose & Fix
  → Read error carefully
  → Identify root cause
  → Apply targeted fix

ATTEMPT 2: Alternative Approach
  → Same error? Try different method
  → NEVER repeat exact same failing action

ATTEMPT 3: Broader Rethink
  → Question assumptions
  → Search for solutions

AFTER 3 FAILURES: Escalate to User
  → Explain what you tried
  → Share the specific error
  → Ask for guidance
```

---

## The 5-Question Reboot Test

If you can answer these, context is solid:

| Question | Answer Source |
|----------|---------------|
| Where am I? | Current group/task in task_plan.md |
| Where am I going? | Remaining groups/tasks |
| What's the goal? | Goal statement in task_plan.md |
| What have I learned? | findings.md |
| What have I done? | progress.md |

---

## Templates

Use templates from `${CLAUDE_PLUGIN_ROOT}/templates/`:
- `task_plan.md` — Task tracking with parallel groups
- `findings.md` — Research storage
- `progress.md` — Session logging

## Scripts

- `${CLAUDE_PLUGIN_ROOT}/scripts/check-complete.sh` — Verify all tasks complete

---

## Final Code Simplification Pass

After ALL tasks are validated complete (final group done), spawn **5 parallel code-simplifier agents** to review and simplify all files created/modified during execution.

### Code Simplification Protocol

**1. COLLECT** - Gather list of all files created/modified:
- Read progress.md to identify all files touched
- Read each progress_[TASK-ID].md section for "Files Created/Modified"
- Deduplicate the file list

**2. PARTITION** - Split files into 5 roughly equal batches

**3. SPAWN** - Launch 5 parallel `code-simplifier:code-simplifier` agents with `run_in_background: true`:

```
run_in_background: true

You are a code simplifier reviewing files from the [feature-name] implementation.

FILES TO REVIEW (batch N of 5):
- [file1.js]
- [file2.js]
- ...

TASK:
1. Read each file
2. Simplify and refine code for clarity, consistency, and maintainability
3. Preserve all functionality - DO NOT change behavior
4. Focus on: removing duplication, improving naming, simplifying logic
5. Return summary of changes made

Do NOT create new files. Only edit existing files from your batch.
```

**4. MERGE** - After all 5 agents complete:
- Collect any findings into findings.md
- Log simplification summary to progress.md
- Run tests to verify no regressions: `npm test`

**5. PROCEED** - Continue to Code Review Pass

---

## Final Code Review Pass

After code simplification and tests pass, spawn **5 parallel code-reviewer agents** to analyze all changes and provide recommendations.

### Code Review Protocol

**1. PARTITION** - Use same file batches from simplification step

**2. SPAWN** - Launch 5 parallel `feature-dev:code-reviewer` agents with `run_in_background: true`:

```
run_in_background: true

You are reviewing code changes from the [feature-name] implementation.

FILES TO REVIEW (batch N of 5):
- [file1.js]
- [file2.js]
- ...

REVIEW FOR:
1. Bugs and logic errors
2. Security vulnerabilities (OWASP top 10)
3. Performance issues
4. Code quality and maintainability
5. Adherence to project conventions (check CLAUDE.md)

OUTPUT FORMAT:
For each issue found, report:
- File and line number
- Severity: CRITICAL / HIGH / MEDIUM / LOW
- Description of issue
- Recommended fix

If no issues found, report "No issues found in batch N"
```

**3. COLLECT** - After all 5 agents complete:
- Gather all issues from each agent
- Filter by confidence (only report issues with ≥80% confidence)
- Deduplicate similar issues

**4. REPORT** - Present findings to user:
```markdown
## Code Review Summary

### Critical Issues (must fix)
- [file:line] - Description

### High Priority
- [file:line] - Description

### Recommendations (optional)
- [file:line] - Description

### Files with No Issues
- file1.js, file2.js, ...
```

**5. DONE** - Report final status to user

---

## Integration with /prd

This skill is designed to work with `/prd`:

1. `/prd` generates PRD with task breakdown
2. `/prd` generates task_plan.md with Execution Groups
3. `/planning-parallel` executes the plan
4. Parallel groups spawn sub-agents
5. Sequential tasks execute directly
6. **Simplification pass: 5 parallel code-simplifier agents clean up changes**
7. **Review pass: 5 parallel code-reviewer agents analyze and report issues**

```
/spawn feature-name
    ↓
/prd (auto-started)
    ↓
/planning-parallel
    ├── Group 1: Spawn BE-001, BE-002, FE-001 in parallel
    ├── Merge results
    ├── Group 2: Spawn dependent tasks
    ├── Merge results
    ├── Sequential: Testing, Delivery
    ├── Simplify: 5x code-simplifier agents (parallel)
    ├── Run tests (verify no regressions)
    └── Review: 5x code-reviewer agents (parallel) → Report to user
```
