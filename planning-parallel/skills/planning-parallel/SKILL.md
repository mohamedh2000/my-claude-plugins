---
name: planning-parallel
version: "1.0.0"
description: File-based planning with parallel sub-agent execution. Fork of planning-with-files that adds memory-safe parallel task execution. Use for complex multi-step tasks that benefit from parallel agent work.
user-invocable: true
allowed-tools:
  - Read
  - Write
  - Edit
  - Bash
  - Glob
  - Grep
  - Task
  - WebFetch
  - WebSearch
---

# Planning with Files (Parallel Edition)

Fork of planning-with-files with support for **parallel sub-agent execution**.

## Core Concept

```
Context Window = RAM (volatile, limited)
Filesystem = Disk (persistent, unlimited)
→ Anything important gets written to disk.
```

## The Three-File Memory Architecture

| File | Purpose | When to Update |
|------|---------|----------------|
| `task_plan.md` | Tasks, groups, progress, decisions | After each task/group |
| `findings.md` | Research, discoveries, decisions | After ANY discovery |
| `progress.md` | Session log, test results | Throughout session |

---

## PARALLEL EXECUTION PROTOCOL

This fork adds memory-safe parallel execution for tasks generated by `/prd`.

### When to Use Parallel Execution

Use parallel execution when task_plan.md contains:
- `## Execution Groups` table with multiple tasks per group
- Tasks marked with `**Group:** N`
- Multiple tasks with no dependencies between them

### Memory Architecture for Parallel Agents

To avoid race conditions, each sub-agent gets **isolated memory files**:

```
SHARED FILES (sub-agents READ only):
├── task_plan.md          ← Orchestrator owns
├── findings.md           ← Context for sub-agents
├── progress.md           ← Context for sub-agents
└── .claude/Task Documents/PRD-*.md

ISOLATED FILES (each sub-agent WRITES to their own):
├── findings_[TASK-ID].md    ← Agent's discoveries
└── progress_[TASK-ID].md    ← Agent's session log
```

### Parallel Execution Flow

**1. DETECT** - Read task_plan.md, find the current Execution Group

**2. SPAWN IN BACKGROUND** - For each task in the parallel group:
- Use Task tool with appropriate agent type
- **CRITICAL**: Set `run_in_background: true` for ALL parallel agents
- ALL tasks in group spawn in a SINGLE message (true parallel)
- Each agent gets their isolated file names
- Store the returned `output_file` paths and `task_id` for each agent

**3. MONITOR & UPDATE** - While agents execute in background:
- Use `TaskOutput` tool with `block: false` to check status without blocking
- Alternatively, use `Read` tool on the `output_file` paths
- **Provide progress updates to the user** as agents complete:
  - "✓ [TASK-ID] complete - [brief summary]"
  - "⏳ [TASK-ID] still in progress..."
- Continue checking periodically until all agents in the group finish

**4. EXECUTE** - Each sub-agent (running in background):
- READS: task_plan.md, findings.md, progress.md, PRD
- WRITES: findings_[TASK-ID].md, progress_[TASK-ID].md
- DOES NOT MODIFY: shared files

**5. MERGE** - After ALL agents in group complete:
- Read all findings_[TASK-ID].md from the group
- Append to findings.md under `## [TASK-ID] Findings`
- Read all progress_[TASK-ID].md from the group
- Append to progress.md
- Update task_plan.md statuses
- Delete sub-agent files (cleanup)
- **Report to user**: "Group [N] complete. Moving to Group [N+1]..."

**6. CONTINUE** - Proceed to next group

### Sub-Agent Prompt Template

For EACH parallel task, spawn with `run_in_background: true`:

```
run_in_background: true
Agent type: [from task_plan.md - senior-backend-engineer | ui-react-specialist | general-purpose]

You are executing [TASK-ID]: [Task Title] for [feature-name].

CONTEXT (read first, DO NOT modify):
- task_plan.md → Find your task under [TASK-ID]
- findings.md → Decisions and rationale from discovery
- .claude/Task Documents/PRD-[name].md → Full requirements
- .claude/CODEBASE_ARCHITECTURE.md → Codebase patterns

YOUR ISOLATED MEMORY FILES (create and update throughout):
- findings_[TASK-ID].md → Your discoveries, decisions, technical notes
- progress_[TASK-ID].md → Your session log: actions, files modified, errors

EXECUTE:
Complete all subtasks for [TASK-ID] listed in task_plan.md.

WHEN COMPLETE:
Return summary: files created/modified, status (complete/blocked), any blockers.
```

### Orchestrator Monitoring Loop

While background agents are running, the orchestrator should:

```
1. SPAWN all group tasks with run_in_background: true
   → Store task_id and output_file for each

2. MONITOR LOOP (repeat until all complete):
   a. For each running agent:
      - Use TaskOutput with block: false, timeout: 5000
      - OR Read the output_file to check progress

   b. Report status updates to user:
      - "⏳ Running: BE-001, FE-001, INFRA-001..."
      - "✓ BE-001 complete: Created user model and migrations"
      - "✓ FE-001 complete: Built UserProfile component"
      - "⏳ Still waiting on: INFRA-001..."

   c. If all complete, exit loop

3. MERGE results from all agents
4. CONTINUE to next group
```

### Post-Group Merge Checklist

After ALL agents in a parallel group complete:

- [ ] Collect all findings_[TASK-ID].md files from the group
- [ ] Append each to findings.md under appropriate headers
- [ ] Collect all progress_[TASK-ID].md files from the group
- [ ] Append each to progress.md
- [ ] Update task_plan.md: Mark all group tasks as complete
- [ ] Log any errors to Errors Encountered table
- [ ] Delete all sub-agent isolated files
- [ ] Check if next group is unblocked, proceed accordingly

---

## Sequential Execution (Non-Parallel Tasks)

For tasks NOT in a parallel group, execute normally:

1. Read task_plan.md to identify current task
2. Execute the task directly (no sub-agent needed)
3. Update findings.md with discoveries
4. Update progress.md with actions taken
5. Mark task complete in task_plan.md
6. Proceed to next task

---

## Critical Rules

### 1. Read Before Decide
Before major decisions, read task_plan.md. Keeps goals in attention window.

### 2. The 2-Action Rule
> "After every 2 view/browser/search operations, IMMEDIATELY save to findings.md"

### 3. Never Repeat Failures
```
if action_failed:
    next_action != same_action
```
Track what you tried. Mutate the approach.

### 4. Log ALL Errors
Every error goes in task_plan.md AND progress.md.

### 5. Single Writer for Shared Files
During parallel execution, ONLY orchestrator writes to:
- task_plan.md
- findings.md (via merge)
- progress.md (via merge)

---

## The 3-Strike Error Protocol

```
ATTEMPT 1: Diagnose & Fix
  → Read error carefully
  → Identify root cause
  → Apply targeted fix

ATTEMPT 2: Alternative Approach
  → Same error? Try different method
  → NEVER repeat exact same failing action

ATTEMPT 3: Broader Rethink
  → Question assumptions
  → Search for solutions

AFTER 3 FAILURES: Escalate to User
  → Explain what you tried
  → Share the specific error
  → Ask for guidance
```

---

## The 5-Question Reboot Test

If you can answer these, context is solid:

| Question | Answer Source |
|----------|---------------|
| Where am I? | Current group/task in task_plan.md |
| Where am I going? | Remaining groups/tasks |
| What's the goal? | Goal statement in task_plan.md |
| What have I learned? | findings.md |
| What have I done? | progress.md |

---

## Templates

Use templates from `${CLAUDE_PLUGIN_ROOT}/templates/`:
- `task_plan.md` — Task tracking with parallel groups
- `findings.md` — Research storage
- `progress.md` — Session logging

## Scripts

- `${CLAUDE_PLUGIN_ROOT}/scripts/check-complete.sh` — Verify all tasks complete

---

## Final Code Simplification Pass

After ALL tasks are validated complete (final group done), spawn **5 parallel code-simplifier agents** to review and simplify all files created/modified during execution.

### Code Simplification Protocol

**1. COLLECT** - Gather list of all files created/modified:
- Read progress.md to identify all files touched
- Read each progress_[TASK-ID].md section for "Files Created/Modified"
- Deduplicate the file list

**2. PARTITION** - Split files into 5 roughly equal batches

**3. SPAWN** - Launch 5 parallel `code-simplifier:code-simplifier` agents:

```
You are a code simplifier reviewing files from the [feature-name] implementation.

FILES TO REVIEW (batch N of 5):
- [file1.js]
- [file2.js]
- ...

TASK:
1. Read each file
2. Simplify and refine code for clarity, consistency, and maintainability
3. Preserve all functionality - DO NOT change behavior
4. Focus on: removing duplication, improving naming, simplifying logic
5. Return summary of changes made

Do NOT create new files. Only edit existing files from your batch.
```

**4. MERGE** - After all 5 agents complete:
- Collect any findings into findings.md
- Log simplification summary to progress.md
- Run tests to verify no regressions: `npm test`

**5. DONE** - Report final status to user

---

## Integration with /prd

This skill is designed to work with `/prd`:

1. `/prd` generates PRD with task breakdown
2. `/prd` generates task_plan.md with Execution Groups
3. `/planning-parallel` executes the plan
4. Parallel groups spawn sub-agents
5. Sequential tasks execute directly
6. **Final pass: 5 parallel code-simplifier agents clean up all changes**

```
/spawn feature-name
    ↓
/prd (auto-started)
    ↓
/planning-parallel
    ├── Group 1: Spawn BE-001, BE-002, FE-001 in parallel
    ├── Merge results
    ├── Group 2: Spawn dependent tasks
    ├── Merge results
    ├── Sequential: Testing, Delivery
    └── Final: 5x code-simplifier agents (parallel)
```
